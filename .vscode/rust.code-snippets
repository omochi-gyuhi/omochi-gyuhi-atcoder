{
  "Proconio Input Block": {
    "prefix": "ip",
    "body": [
      "input! {",
      "  $0",
      "}"
    ],
    "description": "空のinput!ブロック"
  },
  "Input N and Array A": {
    "prefix": "ina",
    "body": [
      "input! {",
      "  n: usize,",
      "  a: [i64; n],",
      "}"
    ],
    "description": "Nと数列Aを受け取る"
  },
  "Input String S (Chars)": {
    "prefix": "ins",
    "body": [
      "input! {",
      "  s: Chars,",
      "}"
    ],
    "description": "文字列SをVec<char>で受け取る"
  },
  "Input Grid (H, W, S)": {
    "prefix": "inhw",
    "body": [
      "input! {",
      "  h: usize,",
      "  w: usize,",
      "  s: [Chars; h],",
      "}"
    ],
    "description": "H, WとグリッドSを受け取る"
  },
  "Input Graph Edges (N, M, UV)": {
    "prefix": "inuv",
    "body": [
      "input! {",
      "  n: usize,",
      "  m: usize,",
      "  edges: [(Usize1, Usize1); m],",
      "}"
    ],
    "description": "N, Mと辺情報(0-indexed)を受け取る"
  },
  "Interval Set (Range Management)": {
    "prefix": "intervalset",
    "body": [
      "use std::collections::BTreeMap;",
      "use std::cmp::max;",
      "",
      "/// 閉区間 [l, r] を管理するセット",
      "/// 重複・隣接する区間は自動的にマージされる",
      "#[derive(Debug, Clone, Default)]",
      "pub struct IntervalSet {",
      "    // key: start, value: end",
      "    map: BTreeMap<i64, i64>,",
      "    // 管理されている区間の長さの合計",
      "    pub total_length: i64,",
      "}",
      "",
      "impl IntervalSet {",
      "    pub fn new() -> Self {",
      "        Self {",
      "            map: BTreeMap::new(),",
      "            total_length: 0,",
      "        }",
      "    }",
      "",
      "    /// 閉区間 [l, r] を追加する",
      "    /// 計算量: O(log N + (削除される区間数)) -> 償却 O(log N)",
      "    pub fn insert(&mut self, mut l: i64, mut r: i64) {",
      "        if l > r { return; }",
      "",
      "        // 1. 左側の既存区間とのマージ判定",
      "        // l より左（またはl自身）から始まる最後の区間を取得",
      "        if let Some((&sl, &sr)) = self.map.range(..=l).next_back() {",
      "            // 既存区間の終わり(sr)が、新しい区間の始まり(l)と接しているか重なっている場合",
      "            // sr + 1 >= l とすることで、[1,2] と [3,4] のような隣接もマージする",
      "            if sr >= l - 1 {",
      "                l = sl;",
      "                r = max(r, sr);",
      "                // 一旦削除（後で統合したものを入れる）",
      "                self.total_length -= sr - sl + 1;",
      "                self.map.remove(&sl);",
      "            }",
      "        }",
      "",
      "        // 2. 右側の既存区間とのマージ判定",
      "        // 始点が [l, r+1] に含まれる区間はすべて巻き込んでマージする",
      "        // r + 1 とすることで隣接区間もマージ対象にする",
      "        while let Some((&sl, &sr)) = self.map.range(l..=r + 1).next() {",
      "            r = max(r, sr);",
      "            self.total_length -= sr - sl + 1;",
      "            self.map.remove(&sl);",
      "        }",
      "",
      "        // 3. マージ後の区間を挿入",
      "        self.map.insert(l, r);",
      "        self.total_length += r - l + 1;",
      "    }",
      "",
      "    /// 閉区間 [l, r] を削除する（くり抜く）",
      "    /// 計算量: O(log N + (分割・削除される区間数))",
      "    pub fn remove(&mut self, l: i64, r: i64) {",
      "        if l > r { return; }",
      "",
      "        // 影響を受ける可能性のある区間を探す (lより前から始まっている可能性がある)",
      "        let start_key = if let Some((&sl, &sr)) = self.map.range(..=l).next_back() {",
      "            sl",
      "        } else {",
      "            l",
      "        };",
      "",
      "        // 削除範囲に重なる区間をリストアップして処理",
      "        let mut to_remove = Vec::new();",
      "        let mut to_add = Vec::new();",
      "",
      "        for (&sl, &sr) in self.map.range(start_key..) {",
      "            if sl > r { break; } // これ以降は影響なし",
      "",
      "            // 重なりがある場合",
      "            if sr >= l {",
      "                to_remove.push(sl);",
      "                self.total_length -= sr - sl + 1;",
      "",
      "                // 左側がはみ出る場合: [sl, l-1] を残す",
      "                if sl < l {",
      "                    to_add.push((sl, l - 1));",
      "                }",
      "                // 右側がはみ出る場合: [r+1, sr] を残す",
      "                if sr > r {",
      "                    to_add.push((r + 1, sr));",
      "                }",
      "            }",
      "        }",
      "",
      "        for k in to_remove {",
      "            self.map.remove(&k);",
      "        }",
      "        for (nl, nr) in to_add {",
      "            self.map.insert(nl, nr);",
      "            self.total_length += nr - nl + 1;",
      "        }",
      "    }",
      "",
      "    /// 指定された座標 x が含まれているか判定",
      "    pub fn contains(&self, x: i64) -> bool {",
      "        if let Some((_, &sr)) = self.map.range(..=x).next_back() {",
      "            sr >= x",
      "        } else {",
      "            false",
      "        }",
      "    }",
      "",
      "    /// 格納されている区間の個数を返す（マージ後の個数）",
      "    pub fn count_intervals(&self) -> usize {",
      "        self.map.len()",
      "    }",
      "}",
      "$0"
    ],
    "description": "Structure to manage set of intervals with automatic merging (std::collections::BTreeMap)"
  },
  "LazySegtree Range Add Sum": {
    "prefix": "lazy_add_sum",
    "body": [
      "use ac_library::*;",
      "use ac_library::{MapMonoid, Monoid};",
      "",
      "struct RangeSum;",
      "",
      "impl Monoid for RangeSum {",
      "    type S = (i64, usize);",
      "",
      "    fn identity() -> Self::S { (0, 0) }",
      "",
      "    fn binary_operation(left: &Self::S, right: &Self::S) -> Self::S {",
      "        (left.0 + right.0, left.1 + right.1)",
      "    }",
      "}",
      "",
      "struct RangeAdd;",
      "",
      "impl MapMonoid for RangeAdd {",
      "    type M = RangeSum;",
      "    type F = i64; // 加算する値",
      "",
      "    fn identity_map() -> Self::F { 0 }",
      "",
      "    fn mapping(&x: &Self::F, &(sum, count): &<Self::M as Monoid>::S) -> <Self::M as Monoid>::S {",
      "        (sum + x * count as i64, count)",
      "    }",
      "",
      "    fn composition(&f: &Self::F, &g: &Self::F) -> Self::F {",
      "        f + g",
      "    }",
      "}",
      "",
      "let mut segtree: LazySegtree<RangeAdd> = ${1:a}.iter().map(|&x| (x, 1)).collect_vec().into();",
      "segtree.apply_range(${2:l}..${3:r}, ${4:x}); // 区間加算",
      "let result = segtree.prod(${5:l}..${6:r}).0; // 区間和"
    ],
    "description": "遅延評価セグメント木（区間加算・区間和）"
  },
  "LazySegtree Range Update Min": {
    "prefix": "lazy_update_min",
    "body": [
      "use ac_library::*;",
      "use ac_library::{MapMonoid, Monoid};",
      "",
      "struct RangeMin;",
      "",
      "impl Monoid for RangeMin {",
      "    type S = i64;",
      "",
      "    fn identity() -> Self::S { i64::MAX }",
      "",
      "    fn binary_operation(&a: &Self::S, &b: &Self::S) -> Self::S {",
      "        a.min(b)",
      "    }",
      "}",
      "",
      "struct RangeUpdate;",
      "",
      "impl MapMonoid for RangeUpdate {",
      "    type M = RangeMin;",
      "    type F = Option<i64>; // None = 更新なし",
      "",
      "    fn identity_map() -> Self::F { None }",
      "",
      "    fn mapping(&f: &Self::F, &x: &<Self::M as Monoid>::S) -> <Self::M as Monoid>::S {",
      "        f.unwrap_or(x)",
      "    }",
      "",
      "    fn composition(&f: &Self::F, &g: &Self::F) -> Self::F {",
      "        f.or(g)",
      "    }",
      "}",
      "",
      "let mut segtree: LazySegtree<RangeUpdate> = Segtree::from(${1:a});",
      "segtree.apply_range(${2:l}..${3:r}, Some(${4:x})); // 区間代入",
      "let result = segtree.prod(${5:l}..${6:r}); // 区間最小値"
    ],
    "description": "遅延評価セグメント木（区間代入・区間最小値）"
  },
  "Use LazySegtree": {
    "prefix": "use_lazy",
    "body": [
      "let mut segtree: LazySegtree<${1:AffineTransform}> = ${2:a}.iter().map(|&x| (x, 1)).collect_vec().into();",
      "segtree.apply_range(${3:l}..${4:r}, ${5:op}); // 区間更新",
      "let result = segtree.prod(${6:l}..${7:r}); // 区間クエリ"
    ],
    "description": "遅延評価セグメント木の使用"
  }
}
