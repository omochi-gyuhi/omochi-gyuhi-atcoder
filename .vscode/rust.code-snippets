{
	// Place your snippets for rust here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"LazySegtree with Affine Transform": {
		"prefix": "lazy_affine",
		"body": [
			"use ac_library::*;",
			"use ac_library::ModInt998244353 as Mint;",
			"use ac_library::{MapMonoid, Monoid};",
			"",
			"// 区間和を管理するモノイド：(合計値, 要素数)",
			"struct RangeSum;",
			"",
			"impl Monoid for RangeSum {",
			"    type S = (Mint, usize);",
			"    ",
			"    fn identity() -> Self::S {",
			"        (Mint::new(0), 0)",
			"    }",
			"    ",
			"    fn binary_operation(left: &Self::S, right: &Self::S) -> Self::S {",
			"        (left.0 + right.0, left.1 + right.1)",
			"    }",
			"}",
			"",
			"// アフィン変換 f(x) = ax + b",
			"struct AffineTransform;",
			"",
			"impl MapMonoid for AffineTransform {",
			"    type M = RangeSum;",
			"    type F = (Mint, Mint); // (a, b) で f(x) = ax + b",
			"    ",
			"    fn identity_map() -> Self::F {",
			"        (Mint::new(1), Mint::new(0))",
			"    }",
			"    ",
			"    fn mapping(transform: &Self::F, range_data: &<Self::M as Monoid>::S) -> <Self::M as Monoid>::S {",
			"        let (a, b) = *transform;",
			"        let (sum, count) = *range_data;",
			"        (a * sum + b * Mint::new(count), count)",
			"    }",
			"    ",
			"    fn composition(outer: &Self::F, inner: &Self::F) -> Self::F {",
			"        let (c, d) = *outer;",
			"        let (a, b) = *inner;",
			"        (c * a, c * b + d)",
			"    }",
			"}",
			"",
			"// 使用例",
			"let mut segtree: LazySegtree<AffineTransform> = ${1:a}.iter().map(|&x| (x, 1)).collect_vec().into();",
			"segtree.apply_range(${2:l}..${3:r}, (${4:a}, ${5:b})); // f(x) = ax + b を適用",
			"let result = segtree.prod(${6:l}..${7:r}).0; // 区間和取得"
		],
		"description": "遅延評価セグメント木（アフィン変換・区間和）"
	},
	"LazySegtree Range Add Sum": {
		"prefix": "lazy_add_sum",
		"body": [
			"use ac_library::*;",
			"use ac_library::{MapMonoid, Monoid};",
			"",
			"struct RangeSum;",
			"",
			"impl Monoid for RangeSum {",
			"    type S = (i64, usize);",
			"    ",
			"    fn identity() -> Self::S { (0, 0) }",
			"    ",
			"    fn binary_operation(left: &Self::S, right: &Self::S) -> Self::S {",
			"        (left.0 + right.0, left.1 + right.1)",
			"    }",
			"}",
			"",
			"struct RangeAdd;",
			"",
			"impl MapMonoid for RangeAdd {",
			"    type M = RangeSum;",
			"    type F = i64; // 加算する値",
			"    ",
			"    fn identity_map() -> Self::F { 0 }",
			"    ",
			"    fn mapping(&x: &Self::F, &(sum, count): &<Self::M as Monoid>::S) -> <Self::M as Monoid>::S {",
			"        (sum + x * count as i64, count)",
			"    }",
			"    ",
			"    fn composition(&f: &Self::F, &g: &Self::F) -> Self::F {",
			"        f + g",
			"    }",
			"}",
			"",
			"let mut segtree: LazySegtree<RangeAdd> = ${1:a}.iter().map(|&x| (x, 1)).collect_vec().into();",
			"segtree.apply_range(${2:l}..${3:r}, ${4:x}); // 区間加算",
			"let result = segtree.prod(${5:l}..${6:r}).0; // 区間和"
		],
		"description": "遅延評価セグメント木（区間加算・区間和）"
	},
	"LazySegtree Range Update Min": {
		"prefix": "lazy_update_min",
		"body": [
			"use ac_library::*;",
			"use ac_library::{MapMonoid, Monoid};",
			"",
			"struct RangeMin;",
			"",
			"impl Monoid for RangeMin {",
			"    type S = i64;",
			"    ",
			"    fn identity() -> Self::S { i64::MAX }",
			"    ",
			"    fn binary_operation(&a: &Self::S, &b: &Self::S) -> Self::S {",
			"        a.min(b)",
			"    }",
			"}",
			"",
			"struct RangeUpdate;",
			"",
			"impl MapMonoid for RangeUpdate {",
			"    type M = RangeMin;",
			"    type F = Option<i64>; // None = 更新なし",
			"    ",
			"    fn identity_map() -> Self::F { None }",
			"    ",
			"    fn mapping(&f: &Self::F, &x: &<Self::M as Monoid>::S) -> <Self::M as Monoid>::S {",
			"        f.unwrap_or(x)",
			"    }",
			"    ",
			"    fn composition(&f: &Self::F, &g: &Self::F) -> Self::F {",
			"        f.or(g)",
			"    }",
			"}",
			"",
			"let mut segtree: LazySegtree<RangeUpdate> = Segtree::from(${1:a});",
			"segtree.apply_range(${2:l}..${3:r}, Some(${4:x})); // 区間代入",
			"let result = segtree.prod(${5:l}..${6:r}); // 区間最小値"
		],
		"description": "遅延評価セグメント木（区間代入・区間最小値）"
	},
	"Use LazySegtree": {
		"prefix": "use_lazy",
		"body": [
			"let mut segtree: LazySegtree<${1:AffineTransform}> = ${2:a}.iter().map(|&x| (x, 1)).collect_vec().into();",
			"segtree.apply_range(${3:l}..${4:r}, ${5:op}); // 区間更新",
			"let result = segtree.prod(${6:l}..${7:r}); // 区間クエリ"
		],
		"description": "遅延評価セグメント木の使用"
	},
	"Define Custom Monoid": {
		"prefix": "def_monoid",
		"body": [
			"struct ${1:MyMonoid};",
			"",
			"impl Monoid for ${1:MyMonoid} {",
			"    type S = ${2:i64};",
			"    ",
			"    fn identity() -> Self::S {",
			"        ${3:0}",
			"    }",
			"    ",
			"    fn binary_operation(left: &Self::S, right: &Self::S) -> Self::S {",
			"        ${4:left + right}",
			"    }",
			"}"
		],
		"description": "Monoidの定義"
	},
	"Define Custom MapMonoid": {
		"prefix": "def_mapmonoid",
		"body": [
			"struct ${1:MyMapMonoid};",
			"",
			"impl MapMonoid for ${1:MyMapMonoid} {",
			"    type M = ${2:MyMonoid};",
			"    type F = ${3:i64};",
			"    ",
			"    fn identity_map() -> Self::F {",
			"        ${4:0}",
			"    }",
			"    ",
			"    fn mapping(f: &Self::F, x: &<Self::M as Monoid>::S) -> <Self::M as Monoid>::S {",
			"        ${5:*x + *f}",
			"    }",
			"    ",
			"    fn composition(f: &Self::F, g: &Self::F) -> Self::F {",
			"        ${6:*f + *g}",
			"    }",
			"}"
		],
		"description": "MapMonoidの定義"
	},
	"Segtree Range Sum": {
		"prefix": "seg_sum",
		"body": [
			"use ac_library::*;",
			"",
			"let mut seg: Segtree<Additive<${1:i64}>> = Segtree::new(${2:n});",
			"for i in 0..${2:n} {",
			"    seg.set(i, ${3:a[i]});",
			"}",
			"",
			"// 更新",
			"seg.set(${4:i}, ${5:x}); // 値を設定",
			"",
			"// クエリ",
			"let sum = seg.prod(${6:l}..${7:r}); // 区間[l,r)の和"
		],
		"description": "セグメント木（区間和）"
	},
	"Segtree Range Max": {
		"prefix": "seg_max",
		"body": [
			"use ac_library::*;",
			"",
			"let mut seg: Segtree<Max<${1:i64}>> = Segtree::new(${2:n});",
			"for i in 0..${2:n} {",
			"    seg.set(i, ${3:a[i]});",
			"}",
			"",
			"// 更新",
			"seg.set(${4:i}, ${5:x}); // 値を設定",
			"",
			"// クエリ",
			"let max = seg.prod(${6:l}..${7:r}); // 区間[l,r)の最大値"
		],
		"description": "セグメント木（区間最大値）"
	},
	"Segtree Range Min": {
		"prefix": "seg_min",
		"body": [
			"use ac_library::*;",
			"",
			"let mut seg: Segtree<Min<${1:i64}>> = Segtree::new(${2:n});",
			"for i in 0..${2:n} {",
			"    seg.set(i, ${3:a[i]});",
			"}",
			"",
			"// 更新",
			"seg.set(${4:i}, ${5:x}); // 値を設定",
			"",
			"// クエリ",
			"let min = seg.prod(${6:l}..${7:r}); // 区間[l,r)の最小値"
		],
		"description": "セグメント木（区間最小値）"
	},
	"Segtree from Vec": {
		"prefix": "seg_from",
		"body": [
			"use ac_library::*;",
			"",
			"// Vecから直接作成",
			"let seg: Segtree<${1:Additive<i64>}> = Segtree::from(${2:a});",
			"",
			"// クエリ",
			"let result = seg.prod(${3:l}..${4:r});"
		],
		"description": "セグメント木（Vecから作成）"
	},
	"Use Segtree": {
		"prefix": "use_seg",
		"body": [
			"let mut seg: Segtree<${1:Additive<i64>}> = Segtree::new(${2:n});",
			"seg.set(${3:i}, ${4:x}); // 更新",
			"let result = seg.prod(${5:l}..${6:r}); // 区間クエリ"
		],
		"description": "セグメント木の使用"
	}
}
